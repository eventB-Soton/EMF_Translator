/*******************************************************************************
 * Copyright (c) 2014, 2020 University of Southampton.
 *
 * This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *    University of Southampton - initial API and implementation
 *******************************************************************************/
package ac.soton.emf.translator.configuration;

import java.io.IOException;
import java.util.Collection;
import java.util.List;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.transaction.TransactionalEditingDomain;

import ac.soton.emf.translator.TranslationDescriptor;

/**
 * Allows specialisation of the generic translator for particular use cases
 *  
 * @author cfs
 *
 */

public interface IAdapter {

	/**
	 * If the adapter needs to store translation wide state it can be set up here
	 * This method will be called at the start of each translation with the root source element of
	 * the translation.
	 * 
	 * @param rootSourceElement - the source element passed to the translator for translation
	 */
	void initialiseAdapter(Object rootSourceElement);
	
	/**
	 * Return true if the translation descriptor describes a new root level target element
	 * 
	 * @param translationDescriptor
	 * @return true if this translation descriptor is generating a root element
	 * @since 3.0
	 */
	boolean isRoot(TranslationDescriptor translationDescriptor);
	
	/**
	 * 
	 * Return the resource URI to be used in creating the new resource to contain the generated model.
	 * The root source element of this translation is passed in case it is needed to construct the URI. (E.g. to find 
	 * the containing project.
	 * 
	 * @param translationDescriptor
	 * @param rootSourceElement
	 * @return
	 */
	URI getComponentURI(TranslationDescriptor translationDescriptor, EObject rootSourceElement);

	/**
	 * This should return a collection of potentially affected resources
	 * The resources should all be loaded in the resource set of the given editing domain.
	 * 
	 * 
	 * N.B. CURRENTLY ALL RESOURCES ARE ASSUMED TO BE WITHIN THE SAME PROJECT AS THE SOURCE ELEMENT. 
	 * (i.e. translationDescriptor.parent is ignored when adding new root level elements)
	 * 
	 * @param editingDomain
	 * @param sourceElement
	 * @return a list of affected Resources
	 * @since 3.0
	 */
	Collection<Resource> getAffectedResources(TransactionalEditingDomain editingDomain, EObject sourceElement) throws IOException ;
		
	/**
	 * Filters out any source elements that should not be translated.
	 *
	 * @param object - the object to be ttested
	 * @param translatorID - the ID of this translation
	 * @return true if this object should be translated and false if it should be filtered out (ignored)
	 * @since 4.0
	 */
	boolean inputFilter(Object object, String translationId);
	
	/**
	 * Filters out any translationDescriptors that should not be acted upon.
	 * This may be because a child is already visible via extension of the refined parent
	 *
	 * @param translationDescriptor
	 * @return true if this translation descriptor should be acted upon and false if it should be filtered out (ignored)
	 */
	boolean outputFilter(TranslationDescriptor translationDescriptor);
	
	/**
	 * whether these two objects are considered to be essentially the same thing
	 * 
	 * @param obj1
	 * @param obj2
	 * @return
	 */
	boolean match(Object obj1, Object obj2);
	
	/**
	 * gets an ID for this translation. 
	 * This ID will be used to annotate all translated elements.
	 * return null if annotation is not required.
	 * 
	 *  (Note that translated elements with the same ID are deleted at the start of any translation
	 *  hence, if translated elements are not annotated, subsequent translations are likely to cause duplication
	 *  of the translated elements)
	 * 
	 * @param the basic id of the translator type irrespective of source
	 * @param object - the root source element being translated
	 * @return
	 * @since 4.0
	 */
	String getTranslationId(String basicTranslatorID, Object rootSourceElement);

	/**
	 * Add any annotations that are required by the translation to the generated element (i.e. the 'value' field in TranslationDescriptor)
	 * a translation ID is passed and the value must be annotated with this for removal of old generated values to work
	 * 
	 * @param translationDescriptor - containing the value to be annotated
	 * @param translationId - the translation ID
	 * @since 4.0
	 */
	void setGeneratedBy(Object target, String translationId);

	/**
	 * Checks whether the given Object was generated by this translation.
	 * 
	 * @param target - the object to be tested
	 * @param translationId - the id of this translation
	 * @return true if the object was generated by the translation given by translationID.
	 * @since 4.0
	 */
	boolean wasGeneratedBy(Object target, String translationId);
	
	/**
	 * sets a reference to the source element that the target element was generated from
	 * 
	 * @param 
	 * @since 4.0
	 */
	void setSourceElement(Object target,  Object source);
	
	/**
	 * Sets the priority attribute of the given object to the given integer value
	 * In translator the object will be an EObject for this to succeed.
	 * 
	 * @param pri - the integer priority of the given object
	 * @param target - the object to have its priority set
	 * @since 4.0
	 */
	void setPriority(Object target, int pri);

	/**
	 * returns the position in the given List feature for the addition of the given new object
	 * @param list - the list in which the given object needs to be placed
	 * @param object - the object to be placed in the list
	 * @return - the position in the list for the object to be placed
	 */
	int getPos(List<?> list, Object object);

	/**
	 * This can be overridden to extend the method of obtaining the component used as the target for translation
	 * This is called when the adapter is initialised in order to cache the target in the storage area
	 * 
	 * @since 4.0
	 */
	Object getTargetComponent(Object sourceElement);
	
}
